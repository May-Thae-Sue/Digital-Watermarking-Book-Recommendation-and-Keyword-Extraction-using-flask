from flask import Flask, jsonify, make_response, request, redirect, url_for, render_template, send_from_directory
from werkzeug.utils import secure_filename
import nltk
import PyPDF2
import textract
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
import re,io,sys,random,os,math,datetime
from fractions import gcd
import hashlib
from PyPDF2 import PdfFileReader, PdfFileWriter
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import inch

## REQUIREMENTS : flask, nltk, PyPDF2, textract

# ********* Note: This script contains four section *******

## 1. Keywords extraction as /keywords === INPUT: JSON data >> { "title" : "value", "abstract" : "abstract_value" }
## 2. Digital watermarking as /watermark === INPUT: form-data >> pdf_file and author_name
## 3. Digital Signature as /digital  === INPUT:  form-data >> pdf_file (with or without watermark)
## 4. Verification Signature as /verification === INPUT: form-data >> pdf_file, p, q, g, h, a, r, s (Note: p,q,g,h,a,r,s are keys generated by running digital signature )

app = Flask(__name__)

output = []

@app.route('/keywords',methods=['POST'])
def extract():
	data = request.get_json()
	nltk.data.path.append('./nltk_data/')
	title = data['title']
	abstract = data['abstract']
	
	book_title = title.lower()
	
	book_stract = abstract.lower()

	input_string = nltk.word_tokenize(book_stract)

	tagged = nltk.pos_tag(input_string)

	for word,tag in enumerate(tagged):
		if tag[1] == "NN" or tag[1] == "NNS" or tag[1] == "NNP" or tag[1] == "NNPS" or tag[1] == "JJ" or tag[1] == "JJR" or tag[1] == "JJS":
			output.append(tag[0])

	return make_response(jsonify({
	"title" : book_title,
	"abstract" : output
	}),200)




################### WATERMARKING ##############################
############ THIS SECTION IS WATERMARK SECTION##############

DOWNLOAD_FOLDER = os.path.dirname(os.path.abspath(__file__)) + '/downloads/'
app.config['DOWNLOAD_FOLDER'] = DOWNLOAD_FOLDER
   
@app.route('/watermark', methods=['POST'])

def index():
	file = request.files['file']
	author = request.form['name']
	if file.filename == '':
		print('No file selected')
			#return redirect(request.url)
	if file and allowed_file(file.filename):
		filename = secure_filename(file.filename)
		file.save(filename)
		process_file(filename,author)
		return redirect(url_for('uploaded_file', filename=filename))

ALLOWED_EXTENSIONS = set(['pdf'])
def allowed_file(filename):
	return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
	
def process_file(path, author):
	watermark(path,author)

def watermark(path,author):
	pdfFileObj = open(path, 'rb') 
	pdfReader = PyPDF2.PdfFileReader(pdfFileObj) 
	pdfWriter = PdfFileWriter()
	f = author
	packet = io.BytesIO()
	can = canvas.Canvas(packet, pagesize=A4)
	width, height = A4
	time = datetime.datetime.today()
	date = time.strftime("%h-%d-%Y %H:%M:%S")
	can.setFont("Times-Roman", 10)
	can.rotate(90)
	can.drawString(0.5*inch, -inch, '''Created by %s at Date: %s''' % ( f, date))
	can.save()
	mywatermark = PdfFileReader(packet)
  
	for page_number in range(pdfReader.getNumPages()):
		wmpageObj = add_watermark(mywatermark, pdfReader.getPage(page_number)) 
		pdfWriter.addPage(wmpageObj) 
	output_stream = open(app.config['DOWNLOAD_FOLDER'] + path, 'wb')
	pdfWriter.write(output_stream)
  
def add_watermark(wmFile, pageObj): 
	pageObj.mergePage(wmFile.getPage(0)) 
	return pageObj

@app.route('/uploads/<filename>')

def uploaded_file(filename):
	return send_from_directory(app.config['DOWNLOAD_FOLDER'], filename, as_attachment=True)




################ DIGITAL SIGNATURE #############################
################ THIS SECTION IS DIGITAL SIGNATURE ############

@app.route('/digital',methods=['POST'])

def digital():

    file = request.files['file']
    filename=secure_filename(file.filename)
    pdfFilePath = filename
    pdfText = extractPdfText(pdfFilePath)
    pattern = re.compile(r"Created by .* at Date: [JFMAJSOND][a-z]{2}-[0-3][0-9]-[0-9]{4} [0-2][0-9]:[0-6][0-9]:[0-6][0-9]")
    keywords = re.sub(pattern,"", pdfText)
    keywords = extractKeywords(keywords)
    output_string = ""
    for i in keywords:
        output_string += i + " "
    return sign(output_string)
    
def extractPdfText(filePath=''):

    fileObject = open(filePath, 'rb')
    pdfFileReader = PyPDF2.PdfFileReader(fileObject)
    totalPageNumber = pdfFileReader.numPages
    currentPageNumber = 0 
    text = ''
    while(currentPageNumber < totalPageNumber ):
        pdfPage = pdfFileReader.getPage(currentPageNumber)
        text = text + pdfPage.extractText()
        currentPageNumber += 1
    if(text == ''):
        text = textract.process(filePath, method='tesseract', encoding='utf-8')
    return text

def extractKeywords(text):
    wordTokens = word_tokenize(text)
    return wordTokens


###### GENERATION DIGITAL SIGNATURE #######
###### GENERATION RANDOM KEYS #####
def rabinMiller(num):

    s = num - 1
    t = 0
    while s % 2 == 0:
        # keep halving s while it is even (and use t
        # to count how many times we halve s)
        s = s // 2
        t += 1

    for trials in range(5): # try to falsify num's primality 5 times
        a = random.randrange(2, num - 1)
        v = pow(a, s, num)
        if v != 1: # this test does not apply if v is 1.
            i = 0
            while v != (num - 1):
                if i == t - 1:
                    return False
                else:
                    i = i + 1
                    v = (v ** 2) % num
    return True


def isPrime(num):

    if (num < 2):
        return False # 0, 1, and negative numbers are not prime

    lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]

    if num in lowPrimes:
        return True
    for prime in lowPrimes:
        if (num % prime == 0):
            return False
    return rabinMiller(num)


def generateLargePrime(keysize):
    while True:
        num = random.randrange(2**(keysize-1), 2**(keysize))
        if isPrime(num):
            return num


#### KEY GENERATION ######


def loopIsPrime(number):

	isNumberPrime = True
	for i in range(0,20):
		isNumberPrime*=isPrime(number)
		if(isNumberPrime == False):
			return isNumberPrime
	return isNumberPrime	
def modexp( base, exp, modulus ):
        return pow(base, exp, modulus)

def keyGeneration():

	loop = True
	while loop:
		k=random.randrange(2**(415), 2**(416)) #416 bits
		q=generateLargePrime(160)
		p=(k*q)+1
		while not (isPrime(p)):
			k=random.randrange(2**(415), 2**(416)) #416 bits
			q=generateLargePrime(160)
			p=(k*q)+1
		L = p.bit_length()
		"""
		g=t^(p-1)/q  %  p
		if(g^q  % p = 1) we found g
		"""
		t = random.randint(1,p-1)
		g = squareAndMultiply(t, (p-1)//q, p)
		
		if(L>=512 and L<=1024 and L%64 == 0 and (gcd(p-1,q)) > 1 and squareAndMultiply(g,q,p) == 1):
			loop = False
			a = random.randint(2,q-1)
			h = squareAndMultiply(g,a,p)
			return str(p),str(q),str(g),str(h),str(a)



##### SIGNING ALGORITHM ##########

def computeInverse (in1,in2):
    aL = [in1]
    bL = [in2]
    tL = [0]
    t = 1
    sL = [1]
    s = 0
    q = math.floor((aL[0]/bL[0]))
    r = (aL[0] - (q*bL[0]))

    while r > 0 :
        temp = (tL[0] - (q*bL[0]))
        tL[0] = t
        t = temp
        temp = (sL[0] - (q*s))
        sL[0] = s
        s = temp
        aL[0] = bL[0]
        bL[0] = r
        q = math.floor(aL[0]/bL[0])
        r = (aL[0] - (q*bL[0]))
    r = bL[0]
    inverse = s % in2
    return inverse


def squareAndMultiply(x,c,n):
	z=1
	c="{0:b}".format(c)[::-1] #reversing the binary string
	l=len(c)
	for i in range(l-1,-1,-1):
		z=pow(z,2)
		z=z%n
		if(c[i] == '1'):
			z=(z*x)%n
	return z	
	
def shaHash(fileName):
	BLOCKSIZE = 65536
	hasher = hashlib.sha1()
	input_str = io.StringIO(fileName)
	buf = input_str.read(BLOCKSIZE)
	while len(buf) > 0:
		buf = buf.encode('utf-8')
		hasher.update(buf)
		buf = input_str.read(BLOCKSIZE)
	hex = "0x"+hasher.hexdigest()
	return int(hex,0) #returns int value of hash

def sign(string):

		fileName = string
		k1,k2,k3,k4,k5 = keyGeneration()
		p=int(k1)
		q=int(k2)
		g=int(k3)
		h=int(k4)
		a=int(k5)
		
		loop = True
		while loop:
			r = random.randint(1,q-1)
			c1 = squareAndMultiply(g,r,p)
			c1 = c1%q
			c2 = shaHash(fileName) + (a*c1)
			Rinverse = computeInverse(r,q)
			c2 = (c2*Rinverse)%q
			
			if(c1 != 0 and c2 != 0):
				loop = False
		
		print(c1)	
		print(c2)	
		return make_response(jsonify({
	"p" : p,
	"q" : q,
	"g" : g,
	"h" : h,
	"a" : a,
	"r" : c1,
	"s" : c2
	}),200)



@app.route('/verification',methods=['POST'])

def verification():
	file = request.files['file']
	p = int(request.form['p'])
	q = int(request.form['q'])
	g = int(request.form['g'])
	h = int(request.form['h'])
	a = int(request.form['a'])
	c1 = int(request.form['r'])
	c2 = int(request.form['s'])
	
	filename=secure_filename(file.filename)
	pdfFilePath = filename
	pdfText = extractPdfText(pdfFilePath)
	pattern = re.compile(r"Created by .* at Date: [JFMAJSOND][a-z]{2}-[0-3][0-9]-[0-9]{4} [0-2][0-9]:[0-6][0-9]:[0-6][0-9]")
	keywords = re.sub(pattern,"", pdfText)
	keywords = extractKeywords(keywords)
	output_string = ""
	for i in keywords:
		output_string += i + " "
	t1= shaHash (output_string)
	inverseC2 = computeInverse(c2,q)
	t1 = (t1*inverseC2)%q
	t2 = computeInverse(c2,q)
	t2 = (t2*c1)%q
	valid1 = squareAndMultiply(g,t1,p)
	valid2 = squareAndMultiply(h,t2,p)
	valid = ((valid1*valid2)%p)%q
	if(valid == c1):
		return "Valid signature"
	else:
		return "Invalid signature"


if __name__ == '__main__':
   app.run(host = "127.0.0.1",port = "5000",debug=True)
